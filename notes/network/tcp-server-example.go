// Пример многопоточного сетевого сервера
//
// В примере продемонстрирован идиоматичный подход к созданию сетевой службы с помощью пакета net.
// Используются основные структуры пакета - net.Listener и net.Conn
// Каждое подключение обрабатывается в отдельной горутине, что делает сервер многопоточным и очень производительным.
// Использование горутин для каждого подключения - ключевая особенность сетевых служб, написанных на Go.
// Это значительно дешевле и быстрее, чем использование потоков ОС (Apache HTTPd).
// Это значительно проще, чем использование цикла событий в рамках потоков (Nginx).
package main

import (
	"log"
	"net"
)

func main() {

	// регистрируем службу на порту 10000 по протоколу TCP
	listener, err := net.Listen("tcp", "localhost:10000")
	if err != nil {
		log.Fatal(err)
	}

	for {
		// принимаем все подключения
		conn, err := listener.Accept()
		if err != nil {
			log.Println(err)
		}
		// обрабатывваем каждое соединение в отдельной горутине
		go handleConn(conn)
	}

	// Подключение: "telnet.exe localhost 10000" (Windows Powershell)
	// Output:  qqqwweerrttyyuuiioopp[[]]

}

// обработчик подключения - считывает по одному символу и печатает его на экране (дублирует при интерактивной работе)
func handleConn(conn net.Conn) {
	// сложная конструкция, чтобы обрадовать статический анализатор проверкой ошибки в методе закрытия соединения
	defer func() {
		err := conn.Close()
		if err != nil {
			log.Fatal(err)

		}
	}()

	for {
		var b [512]byte
		_, err := conn.Read(b[0:])
		if err != nil {
			return
		}
		_, err = conn.Write(b[0:])
		if err != nil {
			return
		}
	}
}
